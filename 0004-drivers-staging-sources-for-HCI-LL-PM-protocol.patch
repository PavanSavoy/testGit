From 0b6e57995de73e14254ea228dde564910b29804f Mon Sep 17 00:00:00 2001
From: Pavan Savoy <pavan_savoy@ti.com>
Date: Mon, 22 Mar 2010 13:20:55 -0400
Subject: [PATCH 4/7] drivers:staging: sources for HCI LL PM protocol

Texas Instruments BT, FM and GPS combo chips/drivers
make use of a single TTY to communicate with the chip.
This module constitutes the proprietary power management
protocol from TI for the BT/FM/GPS combo chips

Signed-off-by: Pavan Savoy <pavan_savoy@ti.com>
---
 drivers/staging/ti-st/st_ll.c |  169 +++++++++++++++++++++++++++++++++++++++++
 drivers/staging/ti-st/st_ll.h |   67 ++++++++++++++++
 2 files changed, 236 insertions(+), 0 deletions(-)
 create mode 100644 drivers/staging/ti-st/st_ll.c
 create mode 100644 drivers/staging/ti-st/st_ll.h

diff --git a/drivers/staging/ti-st/st_ll.c b/drivers/staging/ti-st/st_ll.c
new file mode 100644
index 0000000..5e42cbe
--- /dev/null
+++ b/drivers/staging/ti-st/st_ll.c
@@ -0,0 +1,169 @@
+/*
+ *  Shared Transport driver
+ *	HCI-LL module responsible for TI proprietary HCI_LL protocol
+ *  Copyright (C) 2009 Texas Instruments
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#include "st_ll.h"
+
+/* all debug macros go in here */
+#define ST_LL_ERR(fmt, arg...)  printk(KERN_ERR "(stll):"fmt"\n" , ## arg)
+#if defined(DEBUG)		/* limited debug messages */
+#define ST_LL_DBG(fmt, arg...)  printk(KERN_INFO "(stll):"fmt"\n" , ## arg)
+#define ST_LL_VER(fmt, arg...)
+#elif defined(VERBOSE)		/* very verbose */
+#define ST_LL_DBG(fmt, arg...)  printk(KERN_INFO "(stll):"fmt"\n" , ## arg)
+#define ST_LL_VER(fmt, arg...)  printk(KERN_INFO "(stll):"fmt"\n" , ## arg)
+#else /* error msgs only */
+#define ST_LL_DBG(fmt, arg...)
+#define ST_LL_VER(fmt, arg...)
+#endif
+
+static struct ll_struct_s *ll;
+
+/**********************************************************************/
+/* internal functions */
+static void send_ll_cmd(unsigned char cmd)
+{
+
+	ST_LL_DBG("%s: writing %x", __func__, cmd);
+	st_int_write(&cmd, 1);
+	return;
+}
+
+static void ll_device_want_to_sleep(void)
+{
+	ST_LL_DBG("%s", __func__);
+	/* sanity check */
+	if (ll->ll_state != ST_LL_AWAKE)
+		ST_LL_ERR("ERR hcill: ST_LL_GO_TO_SLEEP_IND"
+			  "in state %ld", ll->ll_state);
+
+	send_ll_cmd(LL_SLEEP_ACK);
+	/* update state */
+	ll->ll_state = ST_LL_ASLEEP;
+}
+
+static void ll_device_want_to_wakeup(void)
+{
+	/* diff actions in diff states */
+	switch (ll->ll_state) {
+	case ST_LL_ASLEEP:
+		send_ll_cmd(LL_WAKE_UP_ACK);	/* send wake_ack */
+		break;
+	case ST_LL_ASLEEP_TO_AWAKE:
+		/* duplicate wake_ind */
+		ST_LL_ERR("duplicate wake_ind while waiting for Wake ack");
+		break;
+	case ST_LL_AWAKE:
+		/* duplicate wake_ind */
+		ST_LL_ERR("duplicate wake_ind already AWAKE");
+		break;
+	case ST_LL_AWAKE_TO_ASLEEP:
+		/* duplicate wake_ind */
+		ST_LL_ERR("duplicate wake_ind");
+		break;
+	}
+	/* update state */
+	ll->ll_state = ST_LL_AWAKE;
+}
+
+/**********************************************************************/
+/* functions invoked by ST Core */
+
+/* called when ST Core wants to
+ * enable ST LL */
+void st_ll_enable(void)
+{
+	ll->ll_state = ST_LL_AWAKE;
+}
+
+/* called when ST Core /local module wants to
+ * disable ST LL */
+void st_ll_disable(void)
+{
+	ll->ll_state = ST_LL_INVALID;
+}
+
+/* called when ST Core wants to update the state */
+void st_ll_wakeup(void)
+{
+	if (likely(ll->ll_state != ST_LL_AWAKE)) {
+		send_ll_cmd(LL_WAKE_UP_IND);	/* WAKE_IND */
+		ll->ll_state = ST_LL_ASLEEP_TO_AWAKE;
+	} else {
+		/* don't send the duplicate wake_indication */
+		ST_LL_ERR(" Chip already AWAKE ");
+	}
+}
+
+/* called when ST Core wants the state */
+unsigned long st_ll_getstate(void)
+{
+	ST_LL_DBG(" returning state %ld", ll->ll_state);
+	return ll->ll_state;
+}
+
+/* called from ST Core, when a PM related packet arrives */
+unsigned long st_ll_sleep_state(unsigned char cmd)
+{
+	switch (cmd) {
+	case LL_SLEEP_IND:	/* sleep ind */
+		ST_LL_DBG("sleep indication recvd");
+		ll_device_want_to_sleep();
+		break;
+	case LL_SLEEP_ACK:	/* sleep ack */
+		ST_LL_ERR("sleep ack rcvd: host shouldn't");
+		break;
+	case LL_WAKE_UP_IND:	/* wake ind */
+		ST_LL_DBG("wake indication recvd");
+		ll_device_want_to_wakeup();
+		break;
+	case LL_WAKE_UP_ACK:	/* wake ack */
+		ST_LL_DBG("wake ack rcvd");
+		ll->ll_state = ST_LL_AWAKE;
+		break;
+	default:
+		ST_LL_ERR(" unknown input/state ");
+		return ST_ERR_FAILURE;
+	}
+	return ST_SUCCESS;
+}
+
+/* Called from ST CORE to initialize ST LL */
+long st_ll_init(void)
+{
+	long err = ST_SUCCESS;
+
+	/* Allocate memory for ST LL private structure */
+	ll = kzalloc(sizeof(*ll), GFP_ATOMIC);
+	if (!ll) {
+		ST_LL_ERR("kzalloc failed to alloc memory for ST LL");
+		err = -ENOMEM;
+		return err;
+	}
+	/* set state to invalid */
+	ll->ll_state = ST_LL_INVALID;
+	return err;
+}
+
+/* Called from ST CORE to de-initialize ST LL */
+long st_ll_deinit(void)
+{
+	kfree(ll);
+	return 0;
+}
diff --git a/drivers/staging/ti-st/st_ll.h b/drivers/staging/ti-st/st_ll.h
new file mode 100644
index 0000000..fff88cb
--- /dev/null
+++ b/drivers/staging/ti-st/st_ll.h
@@ -0,0 +1,67 @@
+/*
+ *  Shared Transport Low Level (ST LL)
+ *
+ *  Copyright (C) 2009 Texas Instruments
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+
+#ifndef ST_LL_H
+#define ST_LL_H
+
+#include <linux/skbuff.h>
+#include "st.h"
+#include "st_core.h"
+
+/* ST LL receiver states */
+#define ST_W4_PACKET_TYPE       0
+#define ST_BT_W4_EVENT_HDR      1
+#define ST_BT_W4_ACL_HDR        2
+#define ST_BT_W4_SCO_HDR        3
+#define ST_BT_W4_DATA           4
+#define ST_FM_W4_EVENT_HDR      5
+#define ST_GPS_W4_EVENT_HDR	6
+
+/* ST LL state machines */
+#define ST_LL_ASLEEP               0
+#define ST_LL_ASLEEP_TO_AWAKE      1
+#define ST_LL_AWAKE                2
+#define ST_LL_AWAKE_TO_ASLEEP      3
+#define ST_LL_INVALID		   4
+
+#define LL_SLEEP_IND	0x30
+#define LL_SLEEP_ACK	0x31
+#define LL_WAKE_UP_IND	0x32
+#define LL_WAKE_UP_ACK	0x33
+
+/* ST LL private information */
+struct ll_struct_s {
+	unsigned long ll_state;	/* ST LL power state */
+};
+
+/* initialize and de-init ST LL */
+long st_ll_init(void);
+long st_ll_deinit(void);
+
+/* enable/disable ST LL along with KIM start/stop
+ * called by ST Core
+ */
+void st_ll_enable(void);
+void st_ll_disable(void);
+
+unsigned long st_ll_getstate(void);
+unsigned long st_ll_sleep_state(unsigned char);
+void st_ll_wakeup(void);
+#endif /* ST_LL_H */
-- 
1.5.4.3

